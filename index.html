<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Crypto</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap@4.4.1/dist/css/bootstrap.min.css" integrity="sha384-Vkoo8x4CGsO3+Hhxv8T/Q5PaXtkKtu6ug5TOeNV6gBiFeWPGFN9MuhOf23Q9Ifjh" crossorigin="anonymous">
</head>
<body>
<div class="container">
    <h1 class="text-center p-5">TD1</h1>
    <div class="text-center">
        # -*- coding: utf-8 -*-
        """
        Spyder Editor

        This is a temporary script file.
        """

        <br>

        def chiffre_par_decalage(n, chaine):<br>
        message_chiffre = []<br>

        for char in chaine:<br>
        if 'A' <= char <= 'Z':<br>
        nouveau_char = chr((ord(char) - ord('A') + n) % 26 + ord('A'))<br>
        message_chiffre.append(nouveau_char)<br>
        else:<br>
        message_chiffre.append(char)<br>

        return ''.join(message_chiffre)<br>

        resultat = chiffre_par_decalage(4, "ABC")<br>
        print(resultat)<br>

        MessageCrypte="JC QAPGNR NMSP BCAMBCP LC BCTPYGR NYQ CRPC JMLE Y DYGPC HC JC BMLLCPYG QSP AC KCKC DMPSK"<br>
        lg=len(MessageCrypte)<br>
        MessageClair= ""<br>

        frequenceLettre = {<br>
        'E': 0.121,
        'A': 0.071,
        'I': 0.065,
        'S': 0.065,
        'N': 0.063,
        'R': 0.060,
        'T': 0.059,
        'O': 0.050,
        'L': 0.049,
        'U': 0.049
        }
        <br>
        for i in range (lg):<br>
        if  MessageCrypte[i]=='':<br>
        MessageClair+=''<br>
        else:<br>
        asc=ord(MessageCrypte[i])-4<br>
        MessageClair+=chr(asc+26*((asc<65)-(asc>90)))<br>
        print (MessageClair)
    </div>
    <h1 class="text-center p-5">TD2 RSA</h1>
    <div class="text-center">
        https://github.com/tobyck/rsa-encryption <br>

        import random <br>

        # Retourne le pgcd de a et b<br>
        def gcd(a, b):<br>
        while b != 0:<br>
        a, b = b, a % b<br>
        return a<br>

        # Génération et retourne un nombre premier<br>
        def generate_random_prime():<br>
        isPrime = False<br>
        # On boucle tant que nous n'avons pas de nombre premier<br>
        while not isPrime:<br>
        # Sélectionne un nombre aléatoire compris entre 1000 et 1,000,000<br>
        x = random.randrange(pow(10,3), pow(10,6), 1)<br>
        # Le flag passe à vrai quand le nombre n'est pas premier<br>
        flag = False<br>
        # La boucle s'arrête lorsque le nombre n'est pas premier (flag devient True) ou s'il est premier (isPrime devient True)<br>
        while not flag and not isPrime:<br>
        # Cherche des facteurs<br>
        for i in range(2, x):<br>
        if (x % i) == 0:<br>
        flag = True<br>
        break<br>
        if not flag:<br>
        isPrime = True<br>
        return x<br>

        # Génération de e en fonction de phi<br>
        def generate_e(phi):<br>
        flag = False<br>
        # On boucle tant que e n'est aps premier avec phi<br>
        while not flag:<br>
        # Sélectionne un nombre aléatoire compris entre 100 et phi<br>
        e = random.randint(100, phi)<br>
        if gcd(e, phi) == 1:<br>
        flag = True<br>
        return e<br>

        # Algorithme d'Euclide étendu<br>
        # a est le nombre dont on veut connaître l'inverse<br>
        # b est la taille de l'ensemble Z/bZ (phi dans le cas de cet algo)<br>
        # x et y sont respectivement un des coefficients de bézout et le même coefficient à l'étape n-1<br>
        # Algo décrit ici: https://en.wikipedia.org/wiki/Extended_Euclidean_algorithm#Pseudocode<br>
        def egcd(a, b, x = 0, y = 1):<br>
        x, y = y, x - (b // a) * y<br>
        # Si le reste de b//a est 0, alors on a fini<br>
        if b % a == 0:<br>
        return x, y<br>
        # A chaque nouvelle étape, on rappelle egcd() avec a = b % a et b = a<br>
        # -> Comme dans l'algorithme d'Euclique que l'on a vu en CM<br>
        return egcd(b % a, a, x, y)<br>

        # Génère les clés privées et publiques et les retourne dans un dictionnaire<br>
        def generate_key_pair():<br>
        # Génère deux nombres premiers p et q<br>
        p, q = generate_random_prime(), generate_random_prime()<br>
        n = p * q<br>
        phi = (p - 1) * (q - 1)<br>
        e = generate_e(phi)<br>
        d = egcd(e, phi)[0]<br>
        # Si l'inverse de e (d) est d < 0 ou d > phi, le remettre dans l'intervalle [0, phi-1]<br>
        d %= phi<br>
        keys = {<br>
        "p": p,<br>
        "q": q,<br>
        "phi": phi,<br>
        "public": e,<br>
        "private": d,<br>
        "modulus": n<br>
        }
        return keys<br>

        # Liste de caractères dans l'alphabet<br>
        chars = [char for char in "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789`1234567890-=~!@#$%^&*()_+[]\\{}|;':,./<>? "]<br>

        def encrypt(m, e, n):<br>
        c = []<br>
        # chars.index(m[i]) -> index dans l'alphabet l81<br>
        for i in range(len(m)):<br>
        # Cette opération est celle décrite dans le CM2, elle chiffre une lettre du message complet<br>
        c.append(pow(chars.index(m[i]), e, n))<br>
        # Chaque lettre chiffrée est séparée d'un tiret<br>
        return "-".join([str(num) for num in c])<br>

        def decrypt(c, d, n):<br>
        m = []<br>
        # On re-sépare les caractères chiffrés en splittant sur le tiret<br>
        for i in c.split("-"):<br>
        # On les déchiffre avec l'équation présentée dans le CM2<br>
        m.append(chars[pow(int(i), d, n)])<br>
        # Et on re-colle le message<br>
        return "".join(m)<br>


        key_pair = generate_key_pair()<br>
        cipher = encrypt("Hello world!", key_pair["public"], key_pair["modulus"])<br>
        print("Message chiffré: ", cipher)<br>
        decrypted_message = decrypt(cipher, key_pair["private"], key_pair["modulus"])<br>
        print("Message déchiffré: ", decrypted_message)<br>

    </div>
</div>
</body>
</html>